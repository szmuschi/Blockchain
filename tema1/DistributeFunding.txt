// SPDX-License-Identifier: MIT

pragma solidity >=0.7.0 <0.9.0;

contract DistributeFunding{
    struct recipient{
        string name;
        int share;
        bool withdrawn;
    }
    address payable owner;
    int percentage;
    address payable[] recipientAdresses;
    mapping (address => recipient) recipientInfo;
    int noOfRecipient;

    constructor() {
        owner = payable(msg.sender);
        percentage = 0;
        noOfRecipient = 0;
    }

    event ValueReceived(uint amount);

    function addRecipient(string memory recipientName) public {
        require(noOfRecipient < 5);
        recipientAdresses.push(payable(msg.sender));
        recipientInfo[msg.sender] = recipient({
            name: recipientName,
            share: 20,
            withdrawn: false
        });
        noOfRecipient += 1;
    }

    function getAmount() public view returns (uint256) {
        return address(this).balance;
    }

    function getAddresses() public view returns (address payable[] memory) {
        return recipientAdresses;
    }

    function verifyPercentage(int percent) public returns (bool) {
        if(percentage + percent <= 100){
            percentage += percent;
            return true;
        }
        return false;
    }

    function withdrawAmount() public payable{
        require(recipientInfo[msg.sender].withdrawn == false, "You can withdraw funds only once");
        uint256 sharedSum;
        sharedSum = uint256(int(owner.balance) * recipientInfo[msg.sender].share / 100);
        require(address(this).balance > sharedSum, "insufficient funds");
        address payable user = payable(msg.sender);
        user.transfer(sharedSum);
        recipientInfo[msg.sender].withdrawn = true;
    }

    function getContractAmount() public view returns (uint256) {
        return address(this).balance;
    }

    //need this fallback function to receive money
    receive() external payable {
        emit ValueReceived(msg.value);
    }
}